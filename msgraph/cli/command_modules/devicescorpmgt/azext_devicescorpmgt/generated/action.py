# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------


# pylint: disable=protected-access

# pylint: disable=no-self-use


import argparse
from collections import defaultdict
from knack.util import CLIError





class AddMobileAppCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMobileAppCategories, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter mobile-app-categories. All possible keys are: display-name, last-modified-date-time, id'.
                format(k))
            
        
        return d



class AddVppTokens(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddVppTokens, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'apple-id':
                d['apple_id'] = v[0]
            
            elif kl == 'automatically-update-apps':
                d['automatically_update_apps'] = v[0]
            
            elif kl == 'country-or-region':
                d['country_or_region'] = v[0]
            
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            
            elif kl == 'last-sync-date-time':
                d['last_sync_date_time'] = v[0]
            
            elif kl == 'last-sync-status':
                d['last_sync_status'] = v[0]
            
            elif kl == 'organization-name':
                d['organization_name'] = v[0]
            
            elif kl == 'state':
                d['state'] = v[0]
            
            elif kl == 'token':
                d['token'] = v[0]
            
            elif kl == 'vpp-token-account-type':
                d['vpp_token_account_type'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter vpp-tokens. All possible keys are: apple-id, automatically-update-apps, country-or-region, expiration-date-time, last-modified-date-time, last-sync-date-time, last-sync-status, organization-name, state, token, vpp-token-account-type, id'.
                format(k))
            
        
        return d



class AddManagedAppPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddManagedAppPolicies, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            
            elif kl == 'description':
                d['description'] = v[0]
            
            elif kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            
            elif kl == 'version':
                d['version'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter managed-app-policies. All possible keys are: created-date-time, description, display-name, last-modified-date-time, version, id'.
                format(k))
            
        
        return d



class AddManagedAppStatuses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddManagedAppStatuses, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'version':
                d['version'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter managed-app-statuses. All possible keys are: display-name, version, id'.
                format(k))
            
        
        return d



class AddMdmWindowsInformationProtectionPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMdmWindowsInformationProtectionPolicies, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'azure-rights-management-services-allowed':
                d['azure_rights_management_services_allowed'] = v[0]
            
            elif kl == 'data-recovery-certificate':
                d['data_recovery_certificate'] = v[0]
            
            elif kl == 'enforcement-level':
                d['enforcement_level'] = v[0]
            
            elif kl == 'enterprise-domain':
                d['enterprise_domain'] = v[0]
            
            elif kl == 'enterprise-internal-proxy-servers':
                d['enterprise_internal_proxy_servers'] = v
                
            
            elif kl == 'enterprise-ip-ranges':
                d['enterprise_ip_ranges'] = v
                
            
            elif kl == 'enterprise-ip-ranges-are-authoritative':
                d['enterprise_ip_ranges_are_authoritative'] = v[0]
            
            elif kl == 'enterprise-network-domain-names':
                d['enterprise_network_domain_names'] = v
                
            
            elif kl == 'enterprise-protected-domain-names':
                d['enterprise_protected_domain_names'] = v
                
            
            elif kl == 'enterprise-proxied-domains':
                d['enterprise_proxied_domains'] = v
                
            
            elif kl == 'enterprise-proxy-servers':
                d['enterprise_proxy_servers'] = v
                
            
            elif kl == 'enterprise-proxy-servers-are-authoritative':
                d['enterprise_proxy_servers_are_authoritative'] = v[0]
            
            elif kl == 'exempt-apps':
                d['exempt_apps'] = v
                
            
            elif kl == 'icons-visible':
                d['icons_visible'] = v[0]
            
            elif kl == 'indexing-encrypted-stores-or-items-blocked':
                d['indexing_encrypted_stores_or_items_blocked'] = v[0]
            
            elif kl == 'is-assigned':
                d['is_assigned'] = v[0]
            
            elif kl == 'neutral-domain-resources':
                d['neutral_domain_resources'] = v
                
            
            elif kl == 'protected-apps':
                d['protected_apps'] = v
                
            
            elif kl == 'protection-under-lock-config-required':
                d['protection_under_lock_config_required'] = v[0]
            
            elif kl == 'revoke-on-unenroll-disabled':
                d['revoke_on_unenroll_disabled'] = v[0]
            
            elif kl == 'rights-management-services-template-id':
                d['rights_management_services_template_id'] = v[0]
            
            elif kl == 'smb-auto-encrypted-file-extensions':
                d['smb_auto_encrypted_file_extensions'] = v
                
            
            elif kl == 'assignments':
                d['assignments'] = v
                
            
            elif kl == 'exempt-app-locker-files':
                d['exempt_app_locker_files'] = v
                
            
            elif kl == 'protected-app-locker-files':
                d['protected_app_locker_files'] = v
                
            
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            
            elif kl == 'description':
                d['description'] = v[0]
            
            elif kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            
            elif kl == 'version':
                d['version'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter mdm-windows-information-protection-policies. All possible keys are: azure-rights-management-services-allowed, data-recovery-certificate, enforcement-level, enterprise-domain, enterprise-internal-proxy-servers, enterprise-ip-ranges, enterprise-ip-ranges-are-authoritative, enterprise-network-domain-names, enterprise-protected-domain-names, enterprise-proxied-domains, enterprise-proxy-servers, enterprise-proxy-servers-are-authoritative, exempt-apps, icons-visible, indexing-encrypted-stores-or-items-blocked, is-assigned, neutral-domain-resources, protected-apps, protection-under-lock-config-required, revoke-on-unenroll-disabled, rights-management-services-template-id, smb-auto-encrypted-file-extensions, assignments, exempt-app-locker-files, protected-app-locker-files, created-date-time, description, display-name, last-modified-date-time, version, id'.
                format(k))
            
        
        return d



class AddWindowsInformationProtectionPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddWindowsInformationProtectionPolicies, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'days-without-contact-before-unenroll':
                d['days_without_contact_before_unenroll'] = v[0]
            
            elif kl == 'mdm-enrollment-url':
                d['mdm_enrollment_url'] = v[0]
            
            elif kl == 'minutes-of-inactivity-before-device-lock':
                d['minutes_of_inactivity_before_device_lock'] = v[0]
            
            elif kl == 'number-of-past-pins-remembered':
                d['number_of_past_pins_remembered'] = v[0]
            
            elif kl == 'password-maximum-attempt-count':
                d['password_maximum_attempt_count'] = v[0]
            
            elif kl == 'pin-expiration-days':
                d['pin_expiration_days'] = v[0]
            
            elif kl == 'pin-lowercase-letters':
                d['pin_lowercase_letters'] = v[0]
            
            elif kl == 'pin-minimum-length':
                d['pin_minimum_length'] = v[0]
            
            elif kl == 'pin-special-characters':
                d['pin_special_characters'] = v[0]
            
            elif kl == 'pin-uppercase-letters':
                d['pin_uppercase_letters'] = v[0]
            
            elif kl == 'revoke-on-mdm-handoff-disabled':
                d['revoke_on_mdm_handoff_disabled'] = v[0]
            
            elif kl == 'windows-hello-for-business-blocked':
                d['windows_hello_for_business_blocked'] = v[0]
            
            elif kl == 'azure-rights-management-services-allowed':
                d['azure_rights_management_services_allowed'] = v[0]
            
            elif kl == 'data-recovery-certificate':
                d['data_recovery_certificate'] = v[0]
            
            elif kl == 'enforcement-level':
                d['enforcement_level'] = v[0]
            
            elif kl == 'enterprise-domain':
                d['enterprise_domain'] = v[0]
            
            elif kl == 'enterprise-internal-proxy-servers':
                d['enterprise_internal_proxy_servers'] = v
                
            
            elif kl == 'enterprise-ip-ranges':
                d['enterprise_ip_ranges'] = v
                
            
            elif kl == 'enterprise-ip-ranges-are-authoritative':
                d['enterprise_ip_ranges_are_authoritative'] = v[0]
            
            elif kl == 'enterprise-network-domain-names':
                d['enterprise_network_domain_names'] = v
                
            
            elif kl == 'enterprise-protected-domain-names':
                d['enterprise_protected_domain_names'] = v
                
            
            elif kl == 'enterprise-proxied-domains':
                d['enterprise_proxied_domains'] = v
                
            
            elif kl == 'enterprise-proxy-servers':
                d['enterprise_proxy_servers'] = v
                
            
            elif kl == 'enterprise-proxy-servers-are-authoritative':
                d['enterprise_proxy_servers_are_authoritative'] = v[0]
            
            elif kl == 'exempt-apps':
                d['exempt_apps'] = v
                
            
            elif kl == 'icons-visible':
                d['icons_visible'] = v[0]
            
            elif kl == 'indexing-encrypted-stores-or-items-blocked':
                d['indexing_encrypted_stores_or_items_blocked'] = v[0]
            
            elif kl == 'is-assigned':
                d['is_assigned'] = v[0]
            
            elif kl == 'neutral-domain-resources':
                d['neutral_domain_resources'] = v
                
            
            elif kl == 'protected-apps':
                d['protected_apps'] = v
                
            
            elif kl == 'protection-under-lock-config-required':
                d['protection_under_lock_config_required'] = v[0]
            
            elif kl == 'revoke-on-unenroll-disabled':
                d['revoke_on_unenroll_disabled'] = v[0]
            
            elif kl == 'rights-management-services-template-id':
                d['rights_management_services_template_id'] = v[0]
            
            elif kl == 'smb-auto-encrypted-file-extensions':
                d['smb_auto_encrypted_file_extensions'] = v
                
            
            elif kl == 'assignments':
                d['assignments'] = v
                
            
            elif kl == 'exempt-app-locker-files':
                d['exempt_app_locker_files'] = v
                
            
            elif kl == 'protected-app-locker-files':
                d['protected_app_locker_files'] = v
                
            
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            
            elif kl == 'description':
                d['description'] = v[0]
            
            elif kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            
            elif kl == 'version':
                d['version'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter windows-information-protection-policies. All possible keys are: days-without-contact-before-unenroll, mdm-enrollment-url, minutes-of-inactivity-before-device-lock, number-of-past-pins-remembered, password-maximum-attempt-count, pin-expiration-days, pin-lowercase-letters, pin-minimum-length, pin-special-characters, pin-uppercase-letters, revoke-on-mdm-handoff-disabled, windows-hello-for-business-blocked, azure-rights-management-services-allowed, data-recovery-certificate, enforcement-level, enterprise-domain, enterprise-internal-proxy-servers, enterprise-ip-ranges, enterprise-ip-ranges-are-authoritative, enterprise-network-domain-names, enterprise-protected-domain-names, enterprise-proxied-domains, enterprise-proxy-servers, enterprise-proxy-servers-are-authoritative, exempt-apps, icons-visible, indexing-encrypted-stores-or-items-blocked, is-assigned, neutral-domain-resources, protected-apps, protection-under-lock-config-required, revoke-on-unenroll-disabled, rights-management-services-template-id, smb-auto-encrypted-file-extensions, assignments, exempt-app-locker-files, protected-app-locker-files, created-date-time, description, display-name, last-modified-date-time, version, id'.
                format(k))
            
        
        return d



class AddAppliedPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAppliedPolicies, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            
            elif kl == 'description':
                d['description'] = v[0]
            
            elif kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            
            elif kl == 'version':
                d['version'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter applied-policies. All possible keys are: created-date-time, description, display-name, last-modified-date-time, version, id'.
                format(k))
            
        
        return d



class AddIntendedPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIntendedPolicies, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            
            elif kl == 'description':
                d['description'] = v[0]
            
            elif kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            
            elif kl == 'version':
                d['version'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter intended-policies. All possible keys are: created-date-time, description, display-name, last-modified-date-time, version, id'.
                format(k))
            
        
        return d



class AddOperations(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOperations, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            
            elif kl == 'state':
                d['state'] = v[0]
            
            elif kl == 'version':
                d['version'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter operations. All possible keys are: display-name, last-modified-date-time, state, version, id'.
                format(k))
            
        
        return d



class AddLargeCover(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.large_cover = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'type':
                d['type'] = v[0]
            
            elif kl == 'value':
                d['value'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter large-cover. All possible keys are: type, value'.
                format(k))
            
        
        return d



class AddDeviceappmanagementDeviceStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceappmanagementDeviceStates, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'device-id':
                d['device_id'] = v[0]
            
            elif kl == 'device-name':
                d['device_name'] = v[0]
            
            elif kl == 'error-code':
                d['error_code'] = v[0]
            
            elif kl == 'install-state':
                d['install_state'] = v[0]
            
            elif kl == 'last-sync-date-time':
                d['last_sync_date_time'] = v[0]
            
            elif kl == 'os-description':
                d['os_description'] = v[0]
            
            elif kl == 'os-version':
                d['os_version'] = v[0]
            
            elif kl == 'user-name':
                d['user_name'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device-states. All possible keys are: device-id, device-name, error-code, install-state, last-sync-date-time, os-description, os-version, user-name, id'.
                format(k))
            
        
        return d



class AddInstallSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.install_summary = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'failed-device-count':
                d['failed_device_count'] = v[0]
            
            elif kl == 'failed-user-count':
                d['failed_user_count'] = v[0]
            
            elif kl == 'installed-device-count':
                d['installed_device_count'] = v[0]
            
            elif kl == 'installed-user-count':
                d['installed_user_count'] = v[0]
            
            elif kl == 'not-installed-device-count':
                d['not_installed_device_count'] = v[0]
            
            elif kl == 'not-installed-user-count':
                d['not_installed_user_count'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter install-summary. All possible keys are: failed-device-count, failed-user-count, installed-device-count, installed-user-count, not-installed-device-count, not-installed-user-count, id'.
                format(k))
            
        
        return d



class AddDataRecoveryCertificate(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.data_recovery_certificate = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'certificate':
                d['certificate'] = v[0]
            
            elif kl == 'description':
                d['description'] = v[0]
            
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            
            elif kl == 'subject-name':
                d['subject_name'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter data-recovery-certificate. All possible keys are: certificate, description, expiration-date-time, subject-name'.
                format(k))
            
        
        return d



class AddEnterpriseInternalProxyServers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseInternalProxyServers, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'resources':
                d['resources'] = v
                
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter enterprise-internal-proxy-servers. All possible keys are: display-name, resources'.
                format(k))
            
        
        return d



class AddEnterpriseNetworkDomainNames(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseNetworkDomainNames, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'resources':
                d['resources'] = v
                
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter enterprise-network-domain-names. All possible keys are: display-name, resources'.
                format(k))
            
        
        return d



class AddEnterpriseProtectedDomainNames(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseProtectedDomainNames, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'resources':
                d['resources'] = v
                
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter enterprise-protected-domain-names. All possible keys are: display-name, resources'.
                format(k))
            
        
        return d



class AddEnterpriseProxyServers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseProxyServers, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'resources':
                d['resources'] = v
                
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter enterprise-proxy-servers. All possible keys are: display-name, resources'.
                format(k))
            
        
        return d



class AddExemptApps(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExemptApps, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'denied':
                d['denied'] = v[0]
            
            elif kl == 'description':
                d['description'] = v[0]
            
            elif kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'product-name':
                d['product_name'] = v[0]
            
            elif kl == 'publisher-name':
                d['publisher_name'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter exempt-apps. All possible keys are: denied, description, display-name, product-name, publisher-name'.
                format(k))
            
        
        return d



class AddNeutralDomainResources(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddNeutralDomainResources, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'resources':
                d['resources'] = v
                
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter neutral-domain-resources. All possible keys are: display-name, resources'.
                format(k))
            
        
        return d



class AddProtectedApps(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProtectedApps, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'denied':
                d['denied'] = v[0]
            
            elif kl == 'description':
                d['description'] = v[0]
            
            elif kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'product-name':
                d['product_name'] = v[0]
            
            elif kl == 'publisher-name':
                d['publisher_name'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter protected-apps. All possible keys are: denied, description, display-name, product-name, publisher-name'.
                format(k))
            
        
        return d



class AddSmbAutoEncryptedFileExtensions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSmbAutoEncryptedFileExtensions, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'resources':
                d['resources'] = v
                
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter smb-auto-encrypted-file-extensions. All possible keys are: display-name, resources'.
                format(k))
            
        
        return d



class AddExemptAppLockerFiles(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExemptAppLockerFiles, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'file':
                d['file'] = v[0]
            
            elif kl == 'file-hash':
                d['file_hash'] = v[0]
            
            elif kl == 'version':
                d['version'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter exempt-app-locker-files. All possible keys are: display-name, file, file-hash, version, id'.
                format(k))
            
        
        return d



class AddProtectedAppLockerFiles(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProtectedAppLockerFiles, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'file':
                d['file'] = v[0]
            
            elif kl == 'file-hash':
                d['file_hash'] = v[0]
            
            elif kl == 'version':
                d['version'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter protected-app-locker-files. All possible keys are: display-name, file, file-hash, version, id'.
                format(k))
            
        
        return d



class AddDeviceStatuses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceStatuses, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'compliance-grace-period-expiration-date-time':
                d['compliance_grace_period_expiration_date_time'] = v[0]
            
            elif kl == 'device-display-name':
                d['device_display_name'] = v[0]
            
            elif kl == 'device-model':
                d['device_model'] = v[0]
            
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            
            elif kl == 'status':
                d['status'] = v[0]
            
            elif kl == 'user-name':
                d['user_name'] = v[0]
            
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device-statuses. All possible keys are: compliance-grace-period-expiration-date-time, device-display-name, device-model, last-reported-date-time, status, user-name, user-principal-name, id'.
                format(k))
            
        
        return d



class AddDeviceStatusSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.device_status_summary = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'configuration-version':
                d['configuration_version'] = v[0]
            
            elif kl == 'error-count':
                d['error_count'] = v[0]
            
            elif kl == 'failed-count':
                d['failed_count'] = v[0]
            
            elif kl == 'last-update-date-time':
                d['last_update_date_time'] = v[0]
            
            elif kl == 'not-applicable-count':
                d['not_applicable_count'] = v[0]
            
            elif kl == 'pending-count':
                d['pending_count'] = v[0]
            
            elif kl == 'success-count':
                d['success_count'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device-status-summary. All possible keys are: configuration-version, error-count, failed-count, last-update-date-time, not-applicable-count, pending-count, success-count, id'.
                format(k))
            
        
        return d



class AddUserStatuses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddUserStatuses, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'devices-count':
                d['devices_count'] = v[0]
            
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            
            elif kl == 'status':
                d['status'] = v[0]
            
            elif kl == 'user-display-name':
                d['user_display_name'] = v[0]
            
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter user-statuses. All possible keys are: devices-count, last-reported-date-time, status, user-display-name, user-principal-name, id'.
                format(k))
            
        
        return d



class AddUserStatusSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.user_status_summary = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'configuration-version':
                d['configuration_version'] = v[0]
            
            elif kl == 'error-count':
                d['error_count'] = v[0]
            
            elif kl == 'failed-count':
                d['failed_count'] = v[0]
            
            elif kl == 'last-update-date-time':
                d['last_update_date_time'] = v[0]
            
            elif kl == 'not-applicable-count':
                d['not_applicable_count'] = v[0]
            
            elif kl == 'pending-count':
                d['pending_count'] = v[0]
            
            elif kl == 'success-count':
                d['success_count'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter user-status-summary. All possible keys are: configuration-version, error-count, failed-count, last-update-date-time, not-applicable-count, pending-count, success-count, id'.
                format(k))
            
        
        return d



class AddCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCategories, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'display-name':
                d['display_name'] = v[0]
            
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter categories. All possible keys are: display-name, last-modified-date-time, id'.
                format(k))
            
        
        return d



class AddCustomSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCustomSettings, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'name':
                d['name'] = v[0]
            
            elif kl == 'value':
                d['value'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter custom-settings. All possible keys are: name, value'.
                format(k))
            
        
        return d



class AddDeviceappmanagementManagedebooksDeviceStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceappmanagementManagedebooksDeviceStates, self).__call__(parser, namespace, action, option_string)
        

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            
            
            if kl == 'device-id':
                d['device_id'] = v[0]
            
            elif kl == 'device-name':
                d['device_name'] = v[0]
            
            elif kl == 'error-code':
                d['error_code'] = v[0]
            
            elif kl == 'install-state':
                d['install_state'] = v[0]
            
            elif kl == 'last-sync-date-time':
                d['last_sync_date_time'] = v[0]
            
            elif kl == 'os-description':
                d['os_description'] = v[0]
            
            elif kl == 'os-version':
                d['os_version'] = v[0]
            
            elif kl == 'user-name':
                d['user_name'] = v[0]
            
            elif kl == 'id':
                d['id'] = v[0]
            
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device-states. All possible keys are: device-id, device-name, error-code, install-state, last-sync-date-time, os-description, os-version, user-name, id'.
                format(k))
            
        
        return d


